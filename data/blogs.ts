export interface Blog {
  id: string;
  title: string;
  date: string;
  tags: string[];
  summary: string;
  content: string;
  image?: string;
}

// Sample blog data
export const blogs: Blog[] = [
  {
    id: "ai-for-predictive-maintenance",
    title: "AI for the Predictive Maintenance of Wind Turbines",
    date: "2025-05-09",
    tags: [
      "AI",
      "Machine Learning",
      "Predictive Maintenance",
      "Wind Turbines",
      "SCADA Data",
    ],
    summary:
      "Exploring how AI and machine learning can optimize the predictive maintenance of wind turbines, making renewable energy more reliable and cost-effective.",
    content: `
# AI for the Predictive Maintenance of Wind Turbines

Predictive maintenance has become a critical area of research as the world shifts towards more sustainable energy sources like wind power. Wind turbines, operating in harsh environments, are prone to various failures that can be costly and challenging to address without effective maintenance strategies. This blog explores how artificial intelligence (AI) and machine learning can enhance the predictive maintenance of wind turbines, using real-world SCADA data from a wind farm in Portugal.

## Why Predictive Maintenance for Wind Turbines?

Wind turbines are complex machines, and their maintenance presents significant challenges due to their remote locations and varying operating conditions. Predictive maintenance aims to identify potential failures before they occur, reducing downtime, improving safety, and optimizing operational costs. Unlike reactive or scheduled maintenance, predictive maintenance leverages real-time data to make proactive decisions, reducing both the frequency and severity of unexpected failures.

## Using AI for Failure Prediction

AI models can analyze the vast amounts of SCADA data generated by wind turbines to identify patterns that indicate imminent failures. The project explored various machine learning algorithms, including:

- **Random Forest**: Performed best overall, balancing high precision and recall
- **XGBoost**: Known for fast computation and high accuracy
- **Multilayer Perceptron (MLP)**: Captured complex, non-linear relationships
- **Isolation Forest**: Detected anomalies effectively
- **Custom Class Confidence Proportion Decision Tree (CCPDT)**: Designed specifically for handling severe class imbalance

The project focused on optimizing these models using advanced techniques like hyperparameter tuning, class balancing (SMOTE-ENN), and feature engineering to improve prediction accuracy.

## Key Challenges and Solutions

One of the biggest challenges was dealing with the extreme class imbalance, as failures are rare but critical to detect. Techniques like SMOTE-ENN and threshold optimization were used to ensure models remained sensitive to failure events without overwhelming the majority class. Additionally, feature engineering based on domain knowledge significantly improved the models' ability to identify failure patterns.

## Results and Findings

The Random Forest model outperformed others in terms of overall composite score, demonstrating its robustness in high-dimensional data environments. It effectively balanced recall and precision, making it a reliable choice for real-time failure prediction.

## Future Directions

As AI technology continues to evolve, integrating real-time data streams and improving interpretability will be crucial for making predictive maintenance systems more practical and reliable. This project demonstrates the potential of AI to make wind energy more sustainable and cost-effective, contributing to the broader effort to combat climate change.
    `,
    image: "/images/blog/windturbine.jpeg",
  },
  {
    id: "starting-with-wordpress",
    title: "Starting My WordPress Journey",
    date: "2025-05-09",
    tags: ["WordPress", "Gutenberg", "Web Development", "CMS"],
    summary:
      "My first steps into the world of WordPress, exploring the basics of building and customizing websites with the Gutenberg editor.",
    content: `
# Starting My WordPress Journey

I've recently started learning WordPress, specifically focusing on the Gutenberg editor. After mostly building custom projects from scratch, I wanted to explore a more content-focused, user-friendly CMS that powers a huge portion of the web.

## Why WordPress?

WordPress is one of the most widely used content management systems in the world, known for its flexibility, community support, and powerful customization options. It's a great platform for building everything from personal blogs to full-scale business websites, making it a valuable tool for any web developer.

## Getting Started with Gutenberg

I followed [this YouTube tutorial](https://www.youtube.com/watch?v=ERIz3diT9Sk) to get up to speed. It covered the basics, including:

- Setting up a WordPress site
- Understanding the Gutenberg block editor
- Creating pages and posts
- Customizing layouts and content blocks

This was a great introduction, helping me understand the core concepts and features of WordPress without getting too overwhelmed.

## First Impressions

One thing that stood out to me was how quickly you can get a site up and running. Gutenberg's block-based approach makes it easy to design pages without touching a line of code, though I can see the appeal of adding custom HTML and CSS for more control.

## Next Steps

Next, I plan to dive deeper into custom themes, plugins, and more advanced WordPress features. I'm also interested in exploring the performance and SEO aspects of WordPress, as well as integrating it with other tools and platforms.

I’ll keep updating this blog as I learn more and take on bigger projects.
  `,
    image: "/images/blog/wordpress.png",
  },
  {
    id: "building-my-portfolio-with-nextjs",
    title: "Building My Portfolio with Next.js",
    date: "2025-05-09",
    tags: [
      "Next.js",
      "React",
      "Portfolio",
      "Web Development",
      "Vercel",
      "GitHub",
    ],
    summary:
      "How I built my personal portfolio website, hayden-oneill.io, using Next.js, GitHub, and Vercel.",
    content: `
# Building My Portfolio with Next.js

I recently built my personal portfolio website, [hayden-oneill.io](https://hayden-oneill.io), using Next.js. I wanted a place to showcase my projects, share my blogs, and create a central hub for my work as a developer.

## Why I Chose Next.js

Next.js is a React framework that offers powerful features like server-side rendering, static site generation, and API routes, making it perfect for building fast, SEO-friendly websites. Plus, the new App Router made it easier to structure my site as it grew.

## The Tech Stack

For this project, I used:

- **Next.js (App Router)** - For routing and server-side logic
- **TypeScript** - For type safety and better code quality
- **Vercel** - For serverless hosting and fast global content delivery
- **GitHub** - For version control and CI/CD

## Key Features

Some of the main features of my portfolio include:

- A clean, responsive design
- Project showcases and blog posts
- Fast load times with static generation
- Easy content management with Markdown

## Challenges and Lessons Learned

Getting the site structure right with the App Router took some time, but it made the site more maintainable in the long run. I also had to learn a bit about managing TypeScript types across different components, which was a good learning experience.

## Next Steps

I plan to add more projects and blogs as I learn new technologies, and maybe even experiment with interactive components and real-time data features in the future.
  `,
    image: "/images/blog/nextjs.jpg",
  },
  {
    id: "learning-seo-and-site-optimization",
    title: "Learning SEO and Site Optimization",
    date: "2025-05-09",
    tags: [
      "SEO",
      "Web Development",
      "Next.js",
      "Sitemaps",
      "Middleware",
      "Vercel",
    ],
    summary:
      "Exploring the world of SEO, sitemaps, robots.txt, and middleware to improve my portfolio site's visibility.",
    content: `
# Learning SEO and Site Optimization

Once I built my portfolio site, [hayden-oneill.io](https://hayden-oneill.io), I realized how important it is to make sure it’s visible to search engines like Google. This led me down the path of learning about SEO, sitemaps, and how to manage search indexing properly.

## What I’ve Learned So Far

Some of the key SEO techniques I've been learning include:

- **Sitemaps**: I generated a sitemap to help search engines understand my site structure and index it more efficiently.
- **robots.txt**: I created a robots.txt file to control what pages and directories search engines can crawl.
- **Meta Tags and Open Graph**: Adding meta tags for better social sharing previews and search engine descriptions.
- **Middleware**: I experimented with Next.js middleware to handle redirects, headers, and other server-side logic.

## Tools and Hosting

I’m hosting the site on **Vercel**, which integrates seamlessly with **GitHub** for version control and continuous deployment. This setup makes it easy to push updates and experiment with new SEO techniques.

## Next Steps

I plan to dive deeper into optimizing page load speeds, structured data, and other advanced SEO techniques to improve my site's search ranking and user experience.
  `,
    image: "/images/blog/seo.jpg",
  },
  {
    id: "building-cardex-app",
    title: "Building Cardex-App – A Full-Stack Trading Card Tracker",
    date: "2025-05-09",
    tags: [
      "Next.js",
      "React",
      "Full Stack",
      "Authentication",
      "Database",
      "Web Development",
      "Neon DB",
      "Vercel",
      "GitHub",
    ],
    summary:
      "How my friend and I built Cardex-App, a full-stack trading card tracker with user authentication and a Neon database.",
    content: `
# Building Cardex-App – A Full-Stack Trading Card Tracker

Recently, my friend and I launched [Cardex-App](https://cardex-app.com), a full-stack web application for tracking trading card collections. It’s a comprehensive project with both front-end and back-end components, designed to help collectors keep track of their cards, wishlist future pickups, and organize their collections effectively.

## Tech Stack

For this project, we used:

- **Next.js (App Router)** – For the front-end and server-side logic
- **TypeScript** – For cleaner, strongly-typed code
- **Neon DB** – For a fully managed, scalable PostgreSQL database
- **NextAuth.js** – For secure user authentication and session management
- **GitHub** – For version control and collaboration
- **Vercel** – For seamless deployment and fast global content delivery

## Key Features

Some of the main features of Cardex-App include:

- **User Authentication** – Secure login, registration, and password management
- **Email Verification** – To ensure only real users have access
- **Personal Collection Management** – Users can add, edit, and organize their cards
- **Wishlists** – Keep track of the cards you’re looking to add to your collection
- **Responsive Design** – Optimized for mobile and desktop users
- **Real-Time Data** – Fast, reliable database interactions with Neon DB

## Challenges and Lessons Learned

One of the biggest challenges was setting up a reliable and secure authentication system, including email verification. We also had to ensure the database structure was flexible enough to handle different card sets, types, and user preferences without becoming overly complex.

## Next Steps

We plan to add more features, like:

- Advanced search and filtering
- Improved collection analytics
- Personal dashboards for tracking progress
- Enhanced mobile experience

## Final Thoughts

Cardex-App has been a great project for learning the ins and outs of full-stack development, and it's a platform we’re excited to keep improving as our skills grow.
  `,
    image: "/images/blog/cards.webp",
  },
  {
    id: "construction-weather-dashboard",
    title:
      "My Cloud Computing Module – Building a Construction Weather Dashboard",
    date: "2025-05-09",
    tags: [
      "Cloud Computing",
      "PHP",
      "JavaScript",
      "jQuery",
      "Azure",
      "OpenWeather API",
      "Google Maps API",
      "LAMP Stack",
      "MySQL",
      "CSS",
    ],
    summary:
      "How I built a construction weather dashboard using PHP, JavaScript, jQuery, OpenWeather API, Google Maps API, and a LAMP stack on Azure for my cloud computing module.",
    content: `
# My Cloud Computing Module – Building a Construction Weather Dashboard

For my cloud computing module, I had to build a web application that acted as a construction site management dashboard, providing real-time weather updates, safety warnings, and location information for various construction sites. This project required setting up a virtual machine, configuring a LAMP stack, and integrating multiple APIs to create a comprehensive tool for site managers.

## Tech Stack

For this project, I used:

- **PHP** – For server-side logic and API integration
- **JavaScript** – For client-side interactivity and DOM manipulation
- **jQuery** – For simplified AJAX calls and animations
- **MySQL** – For storing site data, user information, and historical weather records
- **CSS** – For styling and responsive design
- **Azure VM (LAMP Stack)** – For hosting the web app
- **OpenWeather API** – For real-time weather data and historical forecasts
- **Google Maps API** – For displaying site locations on an interactive map

## Key Features

Some of the main features of the construction weather dashboard include:

- **Site Management** – Users can add, edit, and delete construction sites, including their location and project details
- **Real-Time Weather Updates** – Current weather data for each site, including temperature, wind speed, and precipitation
- **8-Day Forecast** – Detailed weather predictions for the next 8 days
- **Historical Weather Data** – Users can select a past date to see historical weather conditions at a given site
- **Safety Warnings** – Automated alerts based on weather conditions, like high winds for crane operations or heavy rain for excavation work
- **Interactive Maps** – Uses the Google Maps API to show site locations and weather overlays

## Challenges and Lessons Learned

Setting up the LAMP stack on Azure was a bit challenging, especially configuring the VM for secure remote access and database management. I also had to work on optimizing API calls to reduce latency and avoid exceeding API rate limits. Managing the database structure to store both site details and historical weather data efficiently was another interesting challenge.

## Next Steps

If I revisit this project, I’d like to add:

- Role-based access for different user types (e.g., site managers, safety inspectors)
- Real-time notifications for severe weather alerts
- Improved data visualization for easier site management
- Integration with IoT sensors for on-site weather monitoring

## Final Thoughts

This project gave me a solid understanding of full-stack development, cloud deployment, and API integration. It also taught me a lot about building practical, real-world applications for specific industries like construction.
  `,
    image: "/images/blog/construction.jpg",
  },
];

// Helper function to search blogs
export function searchBlogs(
  query: string,
  selectedTags: string[] = []
): Blog[] {
  if (!query && selectedTags.length === 0) {
    return blogs;
  }

  const lowerCaseQuery = query.toLowerCase();

  return blogs.filter((blog) => {
    // Match by title or content
    const matchesQuery =
      !query ||
      blog.title.toLowerCase().includes(lowerCaseQuery) ||
      blog.content.toLowerCase().includes(lowerCaseQuery) ||
      blog.summary.toLowerCase().includes(lowerCaseQuery);

    // Match by tags
    const matchesTags =
      selectedTags.length === 0 ||
      selectedTags.every((tag) => blog.tags.includes(tag));

    return matchesQuery && matchesTags;
  });
}

// Get all unique tags from blogs
export function getAllTags(): string[] {
  const tagsSet = new Set<string>();

  blogs.forEach((blog) => {
    blog.tags.forEach((tag) => {
      tagsSet.add(tag);
    });
  });

  return Array.from(tagsSet).sort();
}

// Get a blog by ID
export function getBlogById(id: string): Blog | undefined {
  return blogs.find((blog) => blog.id === id);
}
